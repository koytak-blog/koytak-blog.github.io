---
layout: post
title: マルチスレッドアプリケーションの設計 〜マルチスレッドの基本編〜
navtbl: _nav.md
date: 2023/11/02
---
# 基本編
マルチスレッドアプリケーションの設計に関する "あれこれ" を幾つかの記事に分けてシリーズで投稿しています。
本シリーズでは、アプリ種類毎に分けてマルチスレッドアプリケーションについて解説しますが、基本的なところは独立した投稿で説明したいと思います。

{% include_relative _toc.md %}

# マルチスレッドのデザインパターン

マルチスレッドや非同期処理を実装する時のデザインパターンは、歴史と共に幾つかの方法が提供されてきました。C# では以下のデザインパターンがあります。ちなみに、APM と EAP は古い方法なので、現在、推奨されるデザインパターンは TAP と async/await です。
-  [APM (Asynchronous Programming Model)](https://learn.microsoft.com/ja-jp/dotnet/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm)
-  [EAP (Event-based Asynchronous Pattern)](https://learn.microsoft.com/ja-jp/dotnet/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-eap)
-  [TAP (Task-based Asynchronous Pattern)](https://learn.microsoft.com/ja-jp/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap)
-  [async/await](https://learn.microsoft.com/ja-jp/dotnet/csharp/asynchronous-programming/)

他の言語やランタイムでも同様に何かしらのデザインパターンやそのライブラリが提供されていると思います。
マルチスレッドや非同期処理を学習する上で、これら先人達の工夫の結晶であるデザインパターンを学習する事は凄く勉強になります。

一方で、これらデザインパターンは、その裏側にある本質の部分が見えなくなってしまうリスクがあります。
本記事では、敢えて基本に立ち返って、できるだけ言語やライブラリに依存しない形で、順に学習しようと思います。
以下の順番でみていきます。

1. スレッドの起動方法（バックグラウンドスレッドにタスクをどうやって実行させるか）
1. スレッドの待機方法（バックグラウンドスレッドの終了をどうやって検知するか）
1. 実行結果の取得方法（バックグラウンドスレッドの処理結果をどこからどうやって取得するか）
1. 例外のハンドリング（例外が発生したときに、どのようにハンドリングするか）
1. スレッドの取消方法（バックグラウンドスレッドを途中でキャンセルするには）

どの言語でどのライブラリを使用してプログラミングした場合でも、この 5 つの機能は、ほとんどのライブラリで提供されていると思われます。

## スレッドの起動

最も簡単なマルチスレッドプログラムを作成しながらスレッドの起動方法を理解します。既に C# でマルチスレッドプログラミングの経験がある方には簡単な例ですので、肩慣らし程度にお読みください。

### Thread クラスを使用した例

マルチスレッドのプログラミングは概ね以下の手順になります。

1. 別スレッドで処理させるロジックをメソッドの形で実装する
1. スレッドを作成する。この時 1. で作成したメソッドを引数に渡す。なお C# の場合はデリゲートと呼ばれるオブジェクトで渡す
1. スレッドを開始する
1. 別スレッドの終了を待機する(Joinする)


``` csharp
using System.Threading;
// ...中略

// 1. バックグラウンドスレッドで実行したタスクを実装する
static void Run(object count)
{
    int max = (int)count;
    for(int i=0; i<max; i++)
    {
        Thread.Sleep(1000);
        Console.WriteLine("Thr: {0}", i);
    }
}

static void Main(string[] args)
{
    // スレッドで処理するメソッドに渡す引数
    int count = 10;
    // 2. デリゲート（関数ポインタやコマンドパターンに相当）を引数にしてスレッドを作成
    Thread thr = new Thread(new ParameterizedThreadStart(Run));
    // 3. スレッドを開始
    thr.Start(count);
    // 4. スレッドが終了するのを待機
    thr.Join();
}
```

なお、この例は Thread クラスを使用した最も基本的な実装方法です。C# には(おそらく他の言語でも)、もっと便利なシンタックスが沢山ある為、Thread クラスを直接使用する機会は少ないかもしれませんが、最初はこのプログラムの様にベタな方法も理解しておくと良いと思います。

### クロージャを使用する

クロージャ(ラムダ式)はマルチスレッドの機能ではないので、ここで説明するのは不自然かもしれませんが、クロージャを利用する事によりマルチスレッドのプログラムが画期的に書き易くなる為、一緒に理解しておきたいシンタックスです。

前述の例だと、スレッドの処理を実行する関数を予め決められたシグナチャ(引数と戻り値が決っている)の関数として定義しておく必要がありますが、
クロージャを利用するとスレッドから呼び出す関数を予め定義する必要がありません。さらに、**クロージャの外側にあるローカル変数を自由に参照及び書込みできる点**が極めて便利です。
本記事では詳しく説明していませんが、クロージャ及びラムダ式について馴染みの無い方は是非勉強しておく事をお勧めします。

1. スレッドを作成する。この時クロージャ(ラムダ式)をその場で定義して渡す
1. スレッドを開始する。引数 count はクロージャの性質を利用してローカル変数で渡しているので、ここでは指定しない
1. スレッドの終了を待機する場合は Join する

``` csharp
using System.Threading;
// ...中略

static void Main(string[] args)
{
    // クロージャに渡す値
    int count = 10;
    // 1. スレッドを作成する。引数にはスレッドで実行する処理の実体をクロージャで渡す
    Thread thr = new Thread(() =>
    {
        int max = count; // ←クロージャの外側のローカル変数を参照している点に注目
        for (int i = 0; i < max; i++)
        {
            Thread.Sleep(1000);
            Console.WriteLine("Thr: {0}", i);
        }
    });
    // 2. スレッドを開始
    thr.Start();
    // 3. スレッドが終了するのを待機
    thr.Join();
}
```

### スレッドプールを使用する

次は、自分でスレッドを開始するのではなく、事前に開始されているスレッドに処理(タスク)を渡す方法を見てみます。
実際の開発で、直接スレッドを起動する方法とスレッドプールを利用する方法を使い分ける必要はほとんど無いかもしれません。
しかし、サーバーアプリなど高負荷アプリを実装する場合などで、使い分けが必要になるケースがあります。

また、C# の ThreadPool ではタスクの終了を待機する方法がありません。この為、以下の例では、自前で ManualResetEvent を使用して、タスクの終了を待機するようにしています。

1. C# のスレッドプールには、タスク(処理)の終了を通知する方法が無いので、自分で通知用のイベントオブジェクトを用意する
1. ThreadPool クラスの QueueUserWorkItem メソッドに、クロージャ(ラムダ式)をその場で定義して渡す
1. タスクの終了を通知する
1. タスクの終了を待機する


``` csharp
using System.Threading;
using System.Threading.Tasks;

static void Main(string[] args)
{
    // クロージャに渡す値
    int count = 10;
    // 1. スレッドの終了を検知する為のイベント
    ManualResetEvent ev = new(false);
    // 2. ワーカースレッドに、スレッドで実行する処理の実体をクロージャで渡す
    ThreadPool.QueueUserWorkItem((obj) => 
    {
        int max = count; 
        for (int i = 0; i < max; i++)
        {
            Thread.Sleep(1000);
            Console.WriteLine("Thr: {0}", i);
        }
        // 3. タスクの終了を通知する
        ev.Set();
    }, null);
    // 4. タスクが終了するのを待機
    ev.WaitOne();
}
```

C# の場合、この例の様に ThreadPool クラスを直接使用するパターンはやや古いやり方です。なぜなら次に説明する Task クラスなど、他にもっと使い易いクラスがあるからです。
しかし、古いやり方だけあって他の言語やライブラリでも、似た様なシンタックスで実装できる場合が多いので覚えておくと良いと思います。

### Task クラスを使用する

次は、.NET Framework 4 で導入されたタスクベースの非同期パターン(TAP)で使用される Task クラスを使用した例を示します。
ここでは、Thread クラスをそのまま利用する場合と、シンタックス(構文)上の違いはあまりありません。しかし、Task クラスを使用した場合、既定ではスレッドプールが利用されます。

1. スレッド(タスク)を作成し実行する。この時クロージャ(ラムダ式)をその場で定義して渡す
  - スレッドはスレッドプールで自動で実行開始される
  - 引数 count はクロージャの性質を利用してローカル変数で渡しているので、ここでは指定しない
1. 別スレッドの終了を待機する場合は Wait する

``` csharp
using System.Threading;
using System.Threading.Tasks;
// ...中略

static void Main(string[] args)
{
    // クロージャに渡す値
    int count = 10;
    // 1. スレッドを作成して開始する。引数にはスレッドで実行する処理の実体をクロージャで渡す
    Task tsk = Task.Run(() =>
    {
        int max = count;
        for (int i = 0; i < max; i++)
        {
            Thread.Sleep(1000);
            Console.WriteLine("Thr: {0}", i);
        }
    });
    // 2. スレッドが終了するのを待機
    tsk.Wait();
}
```

Task クラスには、その他にもいろいろ便利な機能が備わっており、C# でマルチスレッドをプログラミングする場合は、Task クラスを多用する事になると思います。

## スレッドの待機方法

例えば、今、バックグラウンドスレッドでデータベースからレコードの読み取りしているとします。このバックグラウンドスレッドでの読み取りが完了した時に、メインスレッド側ではどうやってそれを検知すれば良いでしょうか？
スレッドの終了を待機するには、大きく３つの方法があります。

- ステータスポーリング
- イベント通知
- イベント監視

なお、ここで紹介する方法はかなりベタな書きかたです。

### ステータスポーリング

バックグラウンドスレッドの終了を検知するには、メインスレッド側で定期的にスレッドのステータスをポーリングします。

### イベント通知
### イベント監視



## 実行結果の取得方法

## 例外のハンドリング

## スレッドの取消

# 排他制御

# async/await

