---
layout: post
title: マルチスレッドアプリケーションの設計 〜基本編〜
navtbl: _nav.md
date: 2023/11/02
---
# 基本編
マルチスレッドアプリケーションの設計に関する "あれこれ" を幾つかの記事に分けてシリーズで投稿しています。
アプリ種類毎に分けて解説する前に、まずは、基本を押さえようと思います。


{% include_relative _toc.md %}


# スレッドの起動（最初のプログラム）

肩慣らしです。最も簡単なマルチスレッドプログラムを作成してみます。既に C# でマルチスレッドプログラミングの経験がある方は読み飛ばして頂いて大丈夫です。
逆に、自信が無い方は、マルチスレッドプログラミングの感覚を掴んで頂く為にコードを理解できるようにすると良いです。

## Thread クラスを使用した例
マルチスレッドのプログラミングは概ね以下の手順になります。

<ol>
<li>別スレッドで処理させるロジックをメソッドの形で実装する</li>
<li>スレッドを作成する。この時 1. で作成したメソッドを引数に渡す。なお C# の場合はデリゲートと呼ばれるオブジェクトで渡す。</li>
<li>スレッドを開始する</li>
<li>別スレッドの終了を待機する(Joinする)</li>
</ol>

``` csharp
using System.Threading;
// ...中略

// 1. スレッドで処理するロジック（メソッド）を定義します
static void Run(object count)
{
    int max = (int)count;
    for(int i=0; i<max; i++)
    {
        Thread.Sleep(1000);
        Console.WriteLine("Thr: {0}", i);
    }
}

static void Main(string[] args)
{
    // スレッドで処理するメソッドに渡す引数
    int count = 10;
    // 2. デリゲート（関数ポインタやコマンドパターンに相当）を引数にしてスレッドを作成します
    Thread thr = new Thread(new ParameterizedThreadStart(Run));
    // 3. スレッドを開始します
    thr.Start(count);
    // 4. スレッドが終了するのを待機します
    thr.Join();
}
```

なお、この例は Thread クラスを使用した最も基本的な実装方法です。C# には他にもっと便利なシンタックスが沢山あり、最近はこの様な実装を行なう事は少いかもしれません。
ただ、便利なシンタックスを使ってしまうと、中身をよく理解せずに使えてしまう所があるので、最初は、このプログラムの様にベタな方法で実装する事を理解すると良いと思います。

## クロージャを使用する

クロージャはマルチスレッドの機能ではありませんが、クロージャを利用する事によりマルチスレッドのプログラムが画期的に書き易くなる為、一緒に理解しておきたいシンタックスです。

前述の例だと、スレッドの処理を実行する関数を予め決められたシグナチャ(引数と戻り値が決っている)の関数として定義しておく必要がありますが、
クロージャを利用するとスレッドから呼び出す関数を予め定義する必要がありません。さらに、クロージャの外側にあるローカル変数を自由に参照及び書込みできる点が極めて便利です。
以降の記事を読み進める前に、クロージャについて馴染みの無い方は是非勉強しておいてください。本記事ではクロージャについては詳しく説明していません。

<ol>
<li>スレッドを作成する。この時クロージャ(ラムダ式)をその場で定義して渡す</li>
<li>スレッドを開始する。引数 count はクロージャの性質を利用してローカル変数で渡しているので、ここでは指定しない</li>
<li>別スレッドの終了を待機する場合は Join する</li>
</ol>

``` csharp
using System.Threading;
// ...中略

static void Main(string[] args)
{
    // クロージャに渡す値
    int count = 10;

    // 1. スレッドを作成する。引数にはスレッドで実行する処理の実体をクロージャで定義します
    Thread thr = new Thread(() =>
    {
        // クロージャの外側のローカル変数(count)が、クロージャの中から参照も書込みもできる!
        // ここでは参照だけだが、書き込みがある場合は排他制御が必要なので注意
        int max = count;
        for (int i = 0; i < max; i++)
        {
            Thread.Sleep(1000);
            Console.WriteLine("Thr: {0}", i);
        }
    });
    // 2. スレッドを開始します
    thr.Start();
    // 3. スレッドが終了するのを待機します
    thr.Join();
}
```

## Task クラスを使用した例

次に、.NET Framework 4 で導入されたタスクベースの非同期パターン(TAP)で使用される Task クラスを使用した例を示します。

<ol>
<li>スレッド(タスク)を作成し実行する。この時クロージャ(ラムダ式)をその場で定義して渡す</li>
<li>別スレッドの終了を待機する場合は Wait する</li>
</ol>

``` csharp
using System.Threading;
using System.Threading.Tasks;
// ...中略

static void Main(string[] args)
{
    // クロージャに渡す値
    int count = 10;

    // 1. スレッドを作成して開始する。引数にはスレッドで実行する処理の実体をクロージャで定義します
    Task tsk = Task.Run(() =>
    {
        // クロージャの外側のローカル変数(count)が、クロージャの中から参照も書込みもできる!
        int max = count;
        for (int i = 0; i < max; i++)
        {
            Thread.Sleep(1000);
            Console.WriteLine("Thr: {0}", i);
        }
    });

    // 2. スレッドが終了するのを待機します 
    tsk.Wait();
}
```

これは簡単な例なので先述した Thread クラスが Task に置き換わった程度で、あまり違いはありませんが、C# Task クラスには便利な機能が備わっており、C# でマルチスレッドをプログラミングする場合は、本クラスを多用する事になると思いますので、使い方を押えておいてください。

## スレッドプール
# スレッドの待機方法

例えば、バックグラウンドスレッドでデータベースからレコードの読み取りしており、読み取りが完了した時にメインスレッド側ではどうやってそれを検知すれば良いでしょうか？
これには大きく３つの方法があります。

- ステータスポーリング
- イベント通知
- イベント監視

## ステータスポーリング

バックグラウンドスレッドの終了を検知するには、メインスレッド側で定期的にスレッドのステータスをポーリングします。

## イベント通知
## イベント監視

# 実行結果の取得方法

# 例外のハンドリング

# スレッドの取消

# 排他制御

# async/await

