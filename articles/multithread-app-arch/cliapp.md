---
layout: post
title: マルチスレッドアプリケーションの設計 〜対話型アプリ編〜
navtbl: _nav.md
date: 2023/08/17
---
# 対話型アプリ編
マルチスレッドアプリケーションの設計に関する "あれこれ" を幾つかの記事に分けてシリーズで投稿しています。
本記事では対話型アプリをマルチスレッド化する時の考慮点について議論しています。

{% include_relative _toc.md %}

# 対話型アプリにおけるマルチスレッドの設計
ここで言う対話型アプリケーションとは、デスクトップアプリやスマホ上で動作するモバイルアプリ、あるいは Web のフロントエンド(ブラウザ)側など、グラフィカルインターフェースがあり、ユーザーと対話するタイプのアプリケーション全般を想定します。

<br/>
<div style="text-align: center"><img src="assets/cli-interactive-app.svg" alt="対話型アプリ" width="400px" /></div>
<br/>


これらのアプリケーションは、画面上のボタンをクリックしてその結果を画面に表示させるなど、ユーザーのアクションに対応して処理が実行される動きが特徴です。
例としてはメールアプリ、オフィスアプリ（Excel, Word）、地図アプリ、日記アプリ、様々なモバイル端末アプリなどがあります。

## アプリアーキテクチャ

対話側アプリにおいて、最初に理解しておかなければならないのは**メッセージループ**の存在でしょう。メッセージループの存在を知らずして、対話型アプリをマルチスレッド化する意味を理解するのは難しいと思います。

ここでは最初にメッセージループのアーキテクチャについて簡単に説明します。もしあなたがメッセージループが何かを既に理解されているならば、ここは読み飛ばして頂いて大丈夫です。

### メッセージループ

対話型アプリは、ユーザーの操作をイベントとして拾い、そのイベントに対応するイベントハンドラをコーディングする形でアプリを実装していきます。
例えば、ユーザーがマウスでボタンをクリックしたら、そのイベントに対応する「ボタンクリックイベント」のイベントハンドラをコーディングします。

まずは、ユーザーがマウスをクリックしてからイベントハンドラを呼び出すまでの流れを概説してみたいと思います。

<br/>
<div style="text-align: center"><img src="assets/cli-message-loop.svg" alt="メッセージループ" width="800px" /></div>
<br/>

図を見ながら順番に見ていきましょう。<br/>

① ユーザーがマウスやキーボードを操作してイベントを発生させます。これらは、人の操作なので、アプリのスレッドとは全く無関係に発生する非同期的なイベントです。

② ユーザーの操作で発生するイベントは、例えば「マウスが現在座標から X,Y 方向に何ピクセル動いた」「座標 X,Y でマウスクリックした」の様に、そのままではアプリにとっては扱い辛いイベントです。オペレーティングシステムやランタイムは、これらイベントを「ボタンクリック」などの、アプリにとって意味のあるイベントに変換してからアプリに通知します。

③ 発生したイベントをそのタイミングでつ通知されると、アプリはユーザーの操作のタイミングで毎回割り込み処理を実装する必要があり極めて複雑な作りになってしまいます。そこで、イベントを順番に処理できるようにする為に、一旦、イベントをキューに入れます。

④ アプリはキューに入ったイベントを順番にシリアルに**シングルスレッド**で処理します。この処理を担っているのが「メッセージループ」です。

⑤ イベントハンドラの中では、イベントに応じた処理を実装します。

ここで、ポイントとなるのが③と④です。対話型のアプリは**マウスの操作やキーボードの打鍵などの非同期的に発生する人の操作を、シングルスレッドでシリアルに処理している**のです。
なお説明上、ユーザーからイベントを例に挙げましたが、「画面の更新」など内部的に発生するイベントも含めて全てのイベントはキューされてから順番に処理されます。

## マルチスレッド化の目的

前述したように、対話型アプリは様々なイベントをスレッドで順番に処理します。よって、もしどこかの処理で時間が掛ってしまう場合、次のイベントの処理が待たされる事になります。
例えば、ボタンクリックイベントの中でネットワーク通信を行っていたと仮定します。もしネットワークが遅くて通信に時間が掛ってしまった場合、通信中はメッセージループに戻る事ができませんので、画面を更新しようとしても、その更新イベントが待たされます。


<br/>
<div style="text-align: center"><img src="assets/cli-message-freeze.svg" alt="メッセージループでフリーズ" width="700px" /></div>
<br/>

この様に、ユーザーがボタンをクリックしたら、何分間も結果が戻らずに画面がフリーズしてしまうようなアプリは、非常にユーザビリティ（使い勝手）が悪いですね。
この問題の解決策は、時間のかかる処理をバックグラウンドスレッドで実行させます。

<br/>
<div style="text-align: center"><img src="assets/cli-message-async.svg" alt="メッセージループと非同期処理" width="700px" /></div>
<br/>

時間が掛る通信処理をバックグラウンドスレッドに移す事で、メインループでは次のイベントを処理する事ができます。これにより画面のフリーズなども回避され、ユーザビリティの改善する事ができます。

対話型アプリでマルチスレッドを利用する主な目的は、この非同期化によるユーザビリティの改善にあります。しかし、非同期処理を実装する事は、いうほど簡単な作業ではありません。幾つかの考慮点がありますので、それらを順を追って見て行きましょう。

# 非同期処理化

非同期処理を実装する時のデザインパターンは、歴史と共に幾つかの方法が提供されてきました。C# では以下のデザインパターンがあります。ちなみに、APM と EAP は古い方法なので、現在、推奨されるデザインパターンは TAP と async/await です。
-  [APM (Asynchronous Programming Model)](https://learn.microsoft.com/ja-jp/dotnet/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm)
-  [EAP (Event-based Asynchronous Pattern)](https://learn.microsoft.com/ja-jp/dotnet/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-eap)
-  [TAP (Task-based Asynchronous Pattern)](https://learn.microsoft.com/ja-jp/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap)
-  [async/await](https://learn.microsoft.com/ja-jp/dotnet/csharp/asynchronous-programming/)

他の言語やランタイムでも同様に何かしらのデザインパターンやそのライブラリが提供されていると思います。
非同期処理を学習する上で、これら先人達の工夫の結晶であるデザインパターンを学習する事は凄く勉強になります。

一方で、最初から便利な方法に頼ると、本質の部分が見えなくなってしまうリスクがありますので、本記事では、敢えて言語やライブラリに依存しない基本の部分に立ち返って順に学習しようと思います。
以下の順番でみていきます。

1. スレッドの起動方法（バックグラウンドスレッドにタスクをどうやって実行させるか）
1. スレッドの待機方法（バックグラウンドスレッドの終了をどうやって検知するか）
1. 実行結果の取得方法（バックグラウンドスレッドの処理結果をどこにどうやって取得するか）
1. 例外のハンドリング（例外が発生したときに、どのようにハンドリングするか）
1. スレッドの取消方法（バックグラウンドスレッドを途中でキャンセルするには）

どの言語でどのライブラリを使用してプログラミングした場合でも、最初の３つの機能は、必ずなんらかの方法で実装されています。
残りの２つについてもほとんどのライブラリで実装されていると思われます。

## スレッドの起動方法

「スレッドの起動方法」というタイトルにしおておりますが、起動方法というよりも、バックグラウンドのスレッドにタスクを依頼する時に、どういうアーキテクチャがあるかというのを話題にしたいと思います。
大きく次の２パターンがあります。

- 新規にスレッドを作成
- 事前にスレッドを作成

順番に見ていきます。

**新規にスレッドを作成して、タスクを実行する：**<br/>
新規にスレッドを生成する場合は、スレッドクラスのインスタンスに、タスクを関数やラムダ式の形で渡すのが定番です。

``` csharp
static void Method()
{
    int count = 10;
    // 1. スレッドインスタンスを作成する。引数にはスレッドで実行する処理の実体をラムダ式で定義します
    Thread thr = new Thread(() =>
    {
        int max = count;  // ラムダ式の中から外側の変数を参照／書込みできる（クロージャー）
        for (int i = 0; i < max; i++)
        {
            Thread.Sleep(1000);
            Console.WriteLine("Thr: {0}", i);
        }
    });
    // 2. スレッドを開始します
    thr.Start();
    
    // thr.Join(); - スレッドの終了を待機。スレッドの待機方法は後述
```

余談ですが、このラムダ式は外側にあるローカル変数を自由に参照及び書込みできます（クロージャーと呼ばれる機能）。
クロージャはマルチスレッドの機能ではありませんが、クロージャを利用する事によりマルチスレッドのプログラムが画期的に書き易くなる為、一緒に理解しておきたいシンタックスです。

**事前にスレッドを作成しておき、タスクをそのスレッドに渡す：**<br/>
いわゆる「スレッドプール」と呼ばれるのアーキテクチャです。

最近のスレッドライブラリは、使用者側からはスレッドプールのことをほとんど意識しなくても使えるようになっているものがあります。
以下は C# の Task.Run を使用した例ですが、見た目上はスレッドプールを使用している気配がありませんが、背後でスレッドプールを使用しています。

``` csharp
static void Method()
{
    int count = 10;
    // 1. スレッドを作成して開始する。引数にはスレッドで実行する処理の実体をラムダ式で定義します
    // 内部ではスレッドプールが利用される
    Task tsk = Task.Run(() =>
    {
        int max = count;
        for (int i = 0; i < max; i++)
        {
            Thread.Sleep(1000);
            Console.WriteLine("Thr: {0}", i);
        }
    });
    
    // tsk.Wait(); - スレッドの終了を待機。スレッドの待機方法は後述
}
``` 

この記事でテーマにしている対話型アプリに限ると、スレッドプールかどうかはあまり違いはありません（どちらでもいい）が、
サーバーアプリの様に高スループットのアプリだと重要な意味を持つことがあります。シンタックス上は違いがわからない場合でも、
内部アーキテクチャがどうなっているか意識しておくことは重要です。

スレッドプールについてはサーバーアプリ編で取り上げます。

## スレッドの待機方法

例えば、バックグラウンドスレッドでデータベースからレコードの読み取りしており、読み取りが完了した時にメインスレッド側ではどうやってそれを検知すれば良いでしょうか？
これには大きく３つの方法があります。

- ステータスポーリング
- イベント通知
- イベント監視

### ステータスポーリング

バックグラウンドスレッドの終了を検知するには、メインスレッド側で定期的にスレッドのステータスをポーリングします。

## 実行結果の取得方法

# その他の検討ポイント
## 排他制御の設計
## UI スレッドへのポスト
## キャンセルの設計
## 例外の設計
## C# による実装
## Async/Await
# まとめ
