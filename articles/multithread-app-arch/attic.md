---
layout: post
title: 書き散らし記事
date: 2023/08/17
---
没になった記事や書き換え記事

# スレッドの完了を待機する
マルチスレッドプログラミングを行なう場合、スレッド終了を待機して後続の処理を実行するのは頻出するパターンです。
例えば「対話型アプリケーションで、画面をフリーズさせないように外部への通信を別スレッドで非同期実行して結果を画面に表示する」などがあります。

スレッドの待機は対話型アプリ以外でも様々な場面で発生しますが、ここでは、分かり易いように単純なバッチアプリの流れを例にして「スレッドの完了を待機する方法」を考えてみます。
メインスレッド側から「前処理」から開始して「業務処理」を複数のワーカースレッド実行し、すべてのワーカースレッドの完了を待ち合わせしてから「後処理」を実行する。という単純な例です。

なお、ここで「メインスレッド」はプログラムを処理したスレッドを指し、「ワーカースレッド」はタスクを実行するために新たに作成したスレッドを指します。


<br/>
<div style="text-align: center"><img src="assets/syn-thread-join.svg" alt="スレッドの待ち合わせ" width="800px" /></div>
<br/>

## ブロックして待機する

次のソースは、上の図をプログラムで疑似コーディングしたものです。ここでは、全てのワーカースレッドの終了を待ち合わせている部分に着目します。

``` csharp
// 待ち合わせのサンプル
static void BatchJob()
{
    List<Thread> tasks = new List<Thread>();  // タスクリスト

    // 前処理
    PreTask();

    // 業務処理をパラメータを変えて３スレッド作成
    tasks.Add(new Thread(() => { WorkerTask(1); })); // 業務処理１
    tasks.Add(new Thread(() => { WorkerTask(2); })); // 業務処理２
    tasks.Add(new Thread(() => { WorkerTask(3); })); // 業務処理３

    // スレッドの開始
    foreach (Thread t in tasks) { t.Start(); }

    // スレッドの終了待ち
    foreach (Thread t in tasks) { t.Join(); } // ←ここの待機方法を考えてみる

    // 後処理
    PostTask();
}
```

単純にスレッドの完了を待つだけで良いなら ```Join()``` で待機すれば良いのでさほど難しくはありません。
また、Task クラスを用いれば、```Task.WaitAll()```というメソッドが利用できるので、```foreach``` を書く必要がなくさらに簡単に記述できます。

このように、ただ終了を待つだけなら何も難しくありません。
しかし、この例の Join メソッドはスレッドが終了するまで呼び出しから返ってこない（これを「処理がブロックする」と言います）ので、待機している間は、メインスレッドでは何もできません。

これがどういう問題であるかを理解する為に、試しに、スレッドが終了したら終了ステータスを表示するように以下の様に変更してみたとします。

``` csharp
// スレッドの終了待ち（間違いとは言わないがあまり良くない例）
foreach (Thread t in tasks)
{
    t.Join();
    Console.WriteLine("Thread ID:{0} Status:{1}", t.ManagedThreadId, t.ThreadState);
}
```

このコーディングは間違いとは言いませんが、一つ大きな不都合があります。
それは、この実装方法だとスレッドが終了した順番ではなくリストに格納されている順番にログが出力されてしまう点です。
仮に最初のスレッド（業務処理１）が 10 分以上かかるとします。すると、他のスレッドが 1 秒未満で終了したとしても、全てのログが出力されるのは 10 分後です。

これは、ワーカースレッドを待機している間はメインスレッドは何もできないのが原因です。
では、以下の要件の様にスレッドの完了を待機しつつ、別の作業を並行で行ないたい場合はどうしたら良いでしょうか？
- バッチアプリで「スレッドが完了したら、そのスレッドの終了を**すぐに**画面に表示する」
- 対話型アプリで「非同期で実行したスレッドの完了を待ちつつ画面をフリーズさせないようにする」

## 終了を待機する手法
この手の問題を解決する為に、昔から様々なプログラミングパターンが考案されています。C# の APM/EAP/TAP なども、その一例です。
しかし、抽象度の高いフレームワークや C# の async/await の様な便利なシンタックスから勉強してしまうと、マルチスレッドではなく利用しているフレームワークやシンタックスの勉強になってしまうので、
ここでは、もう一段、下のレイヤから話をしたいと思います。

ワーカースレッドの完了を待機しながら、別の作業を並行に行う為には、大きく以下の３つのパターンがあります。

 - ステータスをポーリングする
 - イベントをハンドリングする
 - イベントを監視する

### ステータスをポーリングする
先程の例では Join メソッドがブロックしてしまうので、メインスレッドでは何もできませんでした。
逆を言うと、ブロックしない方法でスレッドの終了をポーリング（定期的に終了したかどうかを確認する）すれば、問題は解決できそうです。
実装イメージを図にするとこんな感じです。

<div style="text-align: center"><img src="assets/syn-status-poling-pattern.svg" alt="ステータスをポーリングする" width="400px" /></div>
<br/>


引数の無い Join は無限に待機するので、処理がブロックする事になりますが、Join の引数には待機する時間を明示的に指定する事ができます。
例えば待機時間に 0 ミリ秒を指定すれば、Join はワーカースレッドの終了だけ確認て直ぐに戻ってくる事が可能です。これを利用して次の様にコーディングします。

``` csharp
// 待ち合わせのサンプル
static void BatchJob()
{
    // ...中略...

    // スレッドの終了待ち
    while (tasks.Count > 0)
    {
        // スレッドがスピンするのを防ぐ
        Thread.Sleep(1000);

        // スレッドを一つづつ確認する
        for (int i = 0; i < tasks.Count; i++)  
        {
            Thread t = tasks[i];

            // タスクが終了しているか、Non-Blocking で確認
            if (t.Join(0) == true)  
            {
                // 終了していた場合、終了したスレッドの情報を表示
                Console.WriteLine("Thread ID:{0} Status:{1}", t.ManagedThreadId, t.ThreadState); 
                // 終了したタスクをリストから削除  
                tasks.RemoveAt(i);    
                // tasks の内容を書き換えたので for ループを抜ける
                break;
            }
        }
    }
    // ...中略...
}
```

このコードだと、Join の引数が 0 ミリ秒なので、全くブロックせず(Non-Blocking)に、ワーカースレッドの終了を確認する事ができます。
このプログラムは問題なく動作しますが欠点もあります。

なお、このコードでは意図的に ```Thread.Sleep(1000)``` を入れていますが、この理由が解りますでしょうか？
この Sleep は while/for のループがフルスピン（全力でぶん回る）しないようにする為のトリックです。
もし、このループがスピンしてしまうと CPU 時間を無駄に大量浪費する可能性があるので、その軽減策です。

一方で、Sleep を入れるとスピンは防げますが、終了確認が一定間隔おきになります（この例の場合は 1000 ミリ秒間隔） 、つまりスレッドが終了してそれを検知するまでに最大 1 秒のタイムラグが発生する可能性があります。
この間隔はチューニングで短かくできますが、どちらにしても、Sleep を入れる事によって、今度は、即時性を要求するタイプのアプリで許容できない問題となる場合があります。

どちらの欠点も、アプリの種類によっては問題にならない事も多いので、この実装がダメな実装という訳ではありません。欠点を理解した上でこの方法を採用するかどうかを決めてください。

**補足説明**
- Sleep の代りに Join の引数で、例えば ```Join(1000)``` としても、スピンを防ぐ事ができます。
ただ、今回のサンプルコードだと、複数のスレッドの Join をそれぞれ呼びだしているので、Join の待機時間を長くすると、確認間隔がさらに長くなってしまう(x スレッド数)ので、今回は Sleep を採用しています。
- Sleep が効果的であるかどうかはアプリの特性にも依存する事も覚えておきましょう。アプリによっては Sleep へ遷移するオーバーヘッドの方が問題となる場合もあります。
特に性能を要求するアプリの場合には、こういった小さい工夫が大きな性能差を生み出します。コーディングの段階では分からない事も多いのでテストしながら最適化を行う必要があります。


### イベントをハンドリングする
スレッドが完了したタイミングでワーカースレッド側でイベントを発生させる（トリガーする）方法です。換言すると、ワーカースレッドが終わったら通知してもらう方法です。
実装イメージを図にするとこんな感じです。実際にはベルを鳴らすのではなく、予め用意したメソッド（イベントハンドラ）をワーカースレッド側から呼びだしてもらいます。


<div style="text-align: center"><img src="assets/syn-event-pattern.svg" alt="イベントをトリガーする" width="400px" /></div>
<br/>

C# の Thread クラスにはイベントを登録する方法がありませんので、以下のソースは疑似コードです（動きません）が、
仮にスレッドが完了した時に呼び出されるイベントが登録可能ならば以下のようなコーディングになります。
(仮に ThreadEx クラスとします)

``` csharp
// 完了時に呼び出されるイベントハンドラを用意
static void TaskCompleted(object sender, EventArgs e)
{
    // ステータスを表示
    Console.WriteLine("Thread ID:{0} Status:{1}", 
	                   ((ThreadEx)sender).ThreadID, ((ThreadEx)sender).ThreadState);
}

// 待ち合わせのサンプル
static void BatchJob()
{
    // ...中略...

    // 業務処理をパラメータを変えて３スレッド作成
    tasks.Add(new ThreadEx(() => { WorkerTask(1); })); // 業務処理１
    tasks.Add(new ThreadEx(() => { WorkerTask(2); })); // 業務処理２
    tasks.Add(new ThreadEx(() => { WorkerTask(3); })); // 業務処理３

    // イベントハンドラの登録
    foreach (ThreadEx t in tasks) { t.ThreadCompleted += TaskCompleted!; }

    // スレッドの開始
    foreach (ThreadEx t in tasks) { t.Start(); }

    // スレッドが完了した時の処理（この例ではステータスの表示）は 
    // TaskCompleted() 側で実行するので、ここは何もせず。

    // 全スレッドの終了待ち
    foreach (ThreadEx t in tasks) { t.Join(); }

    // ...中略...
}
```


### イベントを監視する

# 最初のプログラム

肩慣らしです。最も簡単なマルチスレッドプログラムを作成してみます。既に C# でマルチスレッドプログラミングの経験がある方は読み飛ばして頂いて大丈夫です。
逆に、自信が無い方は、マルチスレッドプログラミングの感覚を掴んで頂く為にコードを理解できるようにすると良いです。

## Thread クラスを使用した例
マルチスレッドのプログラミングは概ね以下の手順になります。

<ol>
<li>別スレッドで処理させるロジックをメソッドの形で実装する</li>
<li>スレッドを作成する。この時 1. で作成したメソッドを引数に渡す。なお C# の場合はデリゲートと呼ばれるオブジェクトで渡す。</li>
<li>スレッドを開始する</li>
<li>別スレッドの終了を待機する(Joinする)</li>
</ol>

``` csharp
using System.Threading;
// ...中略

// 1. スレッドで処理するロジック（メソッド）を定義します
static void Run(object count)
{
    int max = (int)count;
    for(int i=0; i<max; i++)
    {
        Thread.Sleep(1000);
        Console.WriteLine("Thr: {0}", i);
    }
}

static void Main(string[] args)
{
    // スレッドで処理するメソッドに渡す引数
    int count = 10;
    // 2. デリゲート（関数ポインタやコマンドパターンに相当）を引数にしてスレッドを作成します
    Thread thr = new Thread(new ParameterizedThreadStart(Run));
    // 3. スレッドを開始します
    thr.Start(count);
    // 4. スレッドが終了するのを待機します
    thr.Join();
}
```

なお、この例は Thread クラスを使用した最も基本的な実装方法です。C# には他にもっと便利なシンタックスが沢山あり、最近はこの様な実装を行なう事は少いかもしれません。
ただ、便利なシンタックスを使ってしまうと、中身をよく理解せずに使えてしまう所があるので、最初は、このプログラムの様にベタな方法で実装する事を理解すると良いと思います。

## クロージャを使用する

クロージャはマルチスレッドの機能ではありませんが、クロージャを利用する事によりマルチスレッドのプログラムが画期的に書き易くなる為、一緒に理解しておきたいシンタックスです。

前述の例だと、スレッドの処理を実行する関数を予め決められたシグナチャ(引数と戻り値が決っている)の関数として定義しておく必要がありますが、
クロージャを利用するとスレッドから呼び出す関数を予め定義する必要がありません。さらに、クロージャの外側にあるローカル変数を自由に参照及び書込みできる点が極めて便利です。
以降の記事を読み進める前に、クロージャについて馴染みの無い方は是非勉強しておいてください。本記事ではクロージャについては詳しく説明していません。

<ol>
<li>スレッドを作成する。この時クロージャ(ラムダ式)をその場で定義して渡す</li>
<li>スレッドを開始する。引数 count はクロージャの性質を利用してローカル変数で渡しているので、ここでは指定しない</li>
<li>別スレッドの終了を待機する場合は Join する</li>
</ol>

``` csharp
using System.Threading;
// ...中略

static void Main(string[] args)
{
    // クロージャに渡す値
    int count = 10;

    // 1. スレッドを作成する。引数にはスレッドで実行する処理の実体をクロージャで定義します
    Thread thr = new Thread(() =>
    {
        // クロージャの外側のローカル変数(count)が、クロージャの中から参照も書込みもできる!
        // ここでは参照だけだが、書き込みがある場合は排他制御が必要なので注意
        int max = count;
        for (int i = 0; i < max; i++)
        {
            Thread.Sleep(1000);
            Console.WriteLine("Thr: {0}", i);
        }
    });
    // 2. スレッドを開始します
    thr.Start();
    // 3. スレッドが終了するのを待機します
    thr.Join();
}
```

## Task クラスを使用した例

次に、.NET Framework 4 で導入されたタスクベースの非同期パターン(TAP)で使用される Task クラスを使用した例を示します。

<ol>
<li>スレッド(タスク)を作成し実行する。この時クロージャ(ラムダ式)をその場で定義して渡す</li>
<li>別スレッドの終了を待機する場合は Wait する</li>
</ol>

``` csharp
using System.Threading;
using System.Threading.Tasks;
// ...中略

static void Main(string[] args)
{
    // クロージャに渡す値
    int count = 10;

    // 1. スレッドを作成して開始する。引数にはスレッドで実行する処理の実体をクロージャで定義します
    Task tsk = Task.Run(() =>
    {
        // クロージャの外側のローカル変数(count)が、クロージャの中から参照も書込みもできる!
        int max = count;
        for (int i = 0; i < max; i++)
        {
            Thread.Sleep(1000);
            Console.WriteLine("Thr: {0}", i);
        }
    });

    // 2. スレッドが終了するのを待機します 
    tsk.Wait();
}
```

これは簡単な例なので先述した Thread クラスが Task に置き換わった程度で、あまり違いはありませんが、C# Task クラスには便利な機能が備わっており、C# でマルチスレッドをプログラミングする場合は、本クラスを多用する事になると思いますので、使い方を押えておいてください。

# 非同期
 - 非同期の要件
 - Task-based Asynchronous Pattern
 - Event-based Asynchronous Pattern
 - Asynchronous Programming Model
 - asyc/await

# スレッドの起動方法

「スレッドの起動方法」というタイトルにしおておりますが、起動方法というよりも、バックグラウンドのスレッドにタスクを依頼する時に、どういうアーキテクチャがあるかというのを話題にしたいと思います。
大きく次の２パターンがあります。

- 新規にスレッドを作成
- 事前にスレッドを作成

順番に見ていきます。

**新規にスレッドを作成して、タスクを実行する：**<br/>
新規にスレッドを生成する場合は、スレッドクラスのインスタンスに、タスクを関数やラムダ式の形で渡すのが定番です。

``` csharp
static void Method()
{
    int count = 10;
    // 1. スレッドインスタンスを作成する。引数にはスレッドで実行する処理の実体をラムダ式で定義します
    Thread thr = new Thread(() =>
    {
        int max = count;  // ラムダ式の中から外側の変数を参照／書込みできる（クロージャー）
        for (int i = 0; i < max; i++)
        {
            Thread.Sleep(1000);
            Console.WriteLine("Thr: {0}", i);
        }
    });
    // 2. スレッドを開始します
    thr.Start();
    
    // thr.Join(); - スレッドの終了を待機。スレッドの待機方法は後述
```

余談ですが、このラムダ式は外側にあるローカル変数を自由に参照及び書込みできます（クロージャーと呼ばれる機能）。
クロージャはマルチスレッドの機能ではありませんが、クロージャを利用する事によりマルチスレッドのプログラムが画期的に書き易くなる為、一緒に理解しておきたいシンタックスです。

**事前にスレッドを作成しておき、タスクをそのスレッドに渡す：**<br/>
いわゆる「スレッドプール」と呼ばれるのアーキテクチャです。

最近のスレッドライブラリは、使用者側からはスレッドプールのことをほとんど意識しなくても使えるようになっているものがあります。
以下は C# の Task.Run を使用した例ですが、見た目上はスレッドプールを使用している気配がありませんが、背後でスレッドプールを使用しています。

``` csharp
static void Method()
{
    int count = 10;
    // 1. スレッドを作成して開始する。引数にはスレッドで実行する処理の実体をラムダ式で定義します
    // 内部ではスレッドプールが利用される
    Task tsk = Task.Run(() =>
    {
        int max = count;
        for (int i = 0; i < max; i++)
        {
            Thread.Sleep(1000);
            Console.WriteLine("Thr: {0}", i);
        }
    });
    
    // tsk.Wait(); - スレッドの終了を待機。スレッドの待機方法は後述
}
``` 

この記事でテーマにしている対話型アプリに限ると、スレッドプールかどうかはあまり違いはありません（どちらでもいい）が、
サーバーアプリの様に高スループットのアプリだと重要な意味を持つことがあります。シンタックス上は違いがわからない場合でも、
内部アーキテクチャがどうなっているか意識しておくことは重要です。

スレッドプールについてはサーバーアプリ編で取り上げます。

