---
layout: post
title: マルチスレッドアプリケーションの設計 〜はじめに〜
navtbl: _nav.md
date: 2023/11/01
updated: 2023/11/08
---
# はじめに
マルチスレッドアプリケーションの設計に関する "あれこれ" を幾つかの記事に分けてシリーズで投稿しています。

<ul>
<li><a href="./index.html">はじめに</a></li>
<li><a href="./batapp.html">バッチアプリ編</a></li>
<li><a href="./_404.html">対話型アプリ編(準備中)</a></li>
<li><a href="./_404.html">Web アプリ編(準備中)</a></li>
<li><a href="./_404.html">サーバーアプリ編(準備中)</a></li>
</ul>
※未完成な記事については名称等を変更する可能性があります

本記事では、前置きの他、後続の記事を読み進めていく為の準備として、簡単な用語の整理およびプログラムの例を示しています。

{% include_relative _toc.md %}

## 本シリーズについて
アプリをマルチスレッドで実装することで、スループットの向上や応答性能の向上など、様々なメリットが得られます。
しかし、これらのメリットを説明されても、なかなか感覚的にしっくりこない方も多いのではないかと思います。
しっくりこないのは前提としているアプリ（アーキテクチャ）の種類を明示していないからかなと勝手に思いました。
ならば、アプリの種類をいくつかに分類して、それぞれのアプリのアーキテクチャを踏まえて説明するというアプローチにすると、分かり易いのではと考えました。

 - バッチアプリケーション
 - クライアントアプリケーション
 - Web アプリケーション
 - サーバーアプリケーション

なお、この分類は、あくまでマルチスレッドのメリットを理解する為の**便宜上の分類**です。

## 対象となる読者
対象となる読者は、数年程度のシステム設計を経験しており、できれば複数のプログラミング言語でのプログラムの経験がある方を想定しています。
本書では主に C# を用いて説明しておりますが、自分の得意な言語に読み替えられるくらいのスキルがある事が理想です。

また、今、まさに開発を行なっていて「コーディングの仕方」をサクっと調べたい方は、申し訳ありませんが、他の人の記事を当ってください。
本記事のコードは考え方を理解する為の "疑似コード" なので、実アプリとしてはコピペして利用するのは難しいです。
また、体系的な説明になっていないのでリファレンス的な使い方には不向きかと思います。
どちらかというと気持に余裕がある時に読み物的に読んで頂く事を想定しています。

## 解説に利用する環境と言語について

最近のプログラミング言語は、非同期やマルチスレッドをサポートするシンタックスをもっており、マルチスレッドをコーディングするのが簡単になっています。
しかし、便利さ故に、初学者からみるとマルチスレッドの肝心の本質(なぜそのようなコーディングをするのか)に気づけない場合があります。

もちろん、実開発の現場では便利なシンタックスを積極的に利用して下さい。さもないと開発効率や品質の面で不利になります。便利なものは積極的に利用しましょう。
しかし、学習目的の場合は、コーディングは多少面倒でも、低レイヤの API を直接使用したベタな書き方の方がマルチスレッドの理解の為には有益な場合があります。

C# はベタな書き方ができる一方で、言語自体がマルチスレッドや非同期のコーディングをサポートするシンタックスをもっており、一つの言語で新旧両方の書き方を押えられるので、学習には都合が良いです。
そこで、本記事では、Microsoft Windows 上の C# を使用しながら解説する事にします。
なお、考え方そのものは OS やプログラミング言語を問わずに共通しますので、普段他の OS や 言語を使用されている読者の方にも是非読んで頂きたいと考えております。

# マルチスレッド用語の整理
本シリーズを読み進める前に、マルチスレッド界隈でよく使われる用語をいくつか整理しています。

## プロセスとスレッド

<br/>
<div style="text-align: center"><img src="assets/idx-process-thread.svg" alt="プロセスとスレッド" width="600px" /></div>
<br/>

**《プロセス》**<br/>
プロセスとは、プログラムを実行する時に必要な資源一式を管理する機能単位です。
計算機が、あるプログラム処理を実行するには、OS が各処理に CPU 時間やメモリなどの様々な資源を割り当てる必要があります。
プロセスとは、プログラムを実行する為に、OS がメモリなどの各資源の割り当てを行う機能の一つです。
プロセス同士はメモリ空間を含む資源の管理が独立しており、プロセスが異なれば互いに干渉しないように設計されています。
この機能により、例えばあるプロセスがクラッシュしてもその他のプロセスには影響しないようになっています。

初期のころの OS では、プログラムを実行する実体もプロセスでした。
しかし、その後スレッドの登場でプログラムを実行する実体はスレッドになりました。
プロセスは、資源管理を行なう区画としての機能はそのままですが、現在はプロセスそのものは**動かない**と考えます。

なお、ややこしいのですが、文脈や話題の背景によっては「プロセスがプログラムを実行する」と表現する場合もあります。
なので、厳密にはプロセスの実体は動かないけど、表現上は「動く」とする場合はある、くらいに理解していると良いかと思います。

**《スレッド》**<br/>
スレッドとはプロセスの内部で、実際に CPU 時間をスケジューリングして処理を実行する実体であり、プログラムを実行する処理フローそのものを指します。

前述の通り、昔はプロセスは資源管理を行う区画であると同時にプログラムを実行する実体でした。
この為、複数のプログラムを同時実行する為にはプロセスを複数同時実行（マルチプロセス）させる必要がありました。
しかし、計算機の資源は限られています。プロセスが多すぎる場合、プロセス一つ一つにメモリなどの資源を個別に割り当てるとリソースが不足する可能性が高くなります。
そこで、同一のプロセス内で、メモリなどの資源を共有しつつ、プログラムの処理の実行だけを複数同時実行するように「スレッド」という機能が生まれました。
スレッドはプロセスの中でメモリ資源などを共有しながら、プログラムを実行する実体になります。

## ジョブとタスク

<br/>
<div style="text-align: center"><img src="assets/idx-job-task.svg" alt="ジョブとタスク" width="800px" /></div>
<br/>

ジョブやタスクという術語は、文脈や製品によって微妙に異なる意味で使われます(→意味の「ゆれ」があります)。

例えば、一部のジョブ管理システムでは、ジョブやタスクはロジックを組む為の具体的な機能実体です。
Windows OS でのジョブオブジェクトとは一つ以上のプロセスをグループとして制御する機能です。
csh や bash などのシェルからコマンドラインとして起動するコマンド郡をジョブと言います。
実行中のプロセスの事を指してタスクと言う場合があります。C# (.NET) には Task という名前の非同期(スレッド)実行を支援するクラスライブラリがあります。

本記事では厳密に用語を定義する事はしません。以下のように「抽象的」に、ざっくりとした意味で押さえてください。

**《ジョブ》**<br/>
目的を達成する為の一連(複数)のタスクの集まりを意味します。ジョブを構成する個々の処理をタスクと呼びます。

**《タスク》**<br/>
「タスク」は「処理」「作業」又は、当該処理を実装している「プログラム」を指す言葉として使います。

## 並列と並行

<br/>
<div style="text-align: center"><img src="assets/idx-concurrent-parallel.svg" alt="並行と並列" width="800px" /></div>
<br/>

プログラムの処理を複数の処理の流れで同時に実行する場合、大きく並行と並列の２種類の方式があります。
アプリでマルチスレッドをプログラムする場合は、これらの方式の違いをプログラムから制御する事はしません。
というより、通常は OS やスレッドライブラリが良き様にはからってくれるのでプログラマは意図的に制御しないのが普通です。

しかし、これらの概念を意識する事はマルチスレッドアプリの設計する上では重要です。プログラムからの操作方法を詳しく理解する必要はありませんが、両者の概念の違いについては理解する必要があります。

**《並行 - Concurrent》**<br/>
一つの CPU (作業者) が、コンテキストを切り替えながら複数の処理を同時実行する。例えるなら一人の人が洗濯や掃除を同時並行でこなす様。

**《並列 - Parallel》**<br/>
複数の CPU（作業者）が、複数の処理を同時実行する。例えるなら、二人以上の人が洗濯と掃除を分担でこなす様。

なお、並列と並行を区別する必要がない文脈では、いちいち「並列・並行」と書くのは冗長なので、単に「並列」という場合があります。



## 同期と非同期

よく「非同期」という術語がマルチスレッドプログラミングの話題と一緒にでてきますのでこの術語についても触れておきます。

<br/>
<div style="text-align: center"><img src="assets/idx-async-thread.svg" alt="非同期" width="800px" /></div>
<br/>

「非同期」の対義語は「同期」です。これらの用語はプログラムの処理アーキテクチャを意味します。複数の処理において、動作のタイミングを合せるか否かの違いがあります。

**《同期 - Synchronous》**<br/>
スレッド等がお互いにタイミングを取って動作する様を「同期を取る」と表現します。
ある処理(関数など)を呼びだしたとき、その処理の**完了を待つ(応答を待つ)**アーキテクチャの事は同期処理と呼びます。プログラムで通常の関数の呼び出しは同期処理です。

**《非同期 - Asynchronous》**<br/>
スレッド等がお互いにタイミングを合せる事もなく、それぞれが好き勝ってに独立して動作する様を「非同期的に動作する」と表現します。
ある処理(関数など)を呼びだしたときに、その処理の **完了を待たずにすぐ復帰する(応答を待たない)** アーキテクチャの事を非同期処理と呼びます。

**《非同期処理とスレッド》**<br/>
非同期処理を実装する手段の一つとしてスレッドが利用できます。例えば「バックエンドで Web サーバーに接続(通信)しながら、画面の操作を行なう」ようなアーキテクチャは、通常スレッドで実装する事になるでしょう。

一方で「非同期」という言葉はあくまでアーキテクチャを指しますので、実装方法としてはスレッド以外でもありえます。
例えば、画像編集アプリから印刷ボタンで印刷を開始すると、印刷処理はプリンタという別のハードウエアで並列に動作しつつ、
アプリは印刷終了を待たずに操作を継続する事ができます。この場合、非同期処理はハードウエアを利用して実現していると言えます。

# 最初のプログラム

肩慣らしです。最も簡単なマルチスレッドプログラムを作成してみます。既に C# でマルチスレッドプログラミングの経験がある方は読み飛ばして頂いて大丈夫です。
逆に、自信が無い方は、マルチスレッドプログラミングの感覚を掴んで頂く為にコードを理解できるようにすると良いです。

## Thread クラスを使用した例
マルチスレッドのプログラミングは概ね以下の手順になります。

<ol>
<li>別スレッドで処理させるロジックをメソッドの形で実装する</li>
<li>スレッドを作成する。この時 1. で作成したメソッドを引数に渡す。なお C# の場合はデリゲートと呼ばれるオブジェクトで渡す。</li>
<li>スレッドを開始する</li>
<li>別スレッドの終了を待機する(Joinする)</li>
</ol>

``` csharp
using System.Threading;
// ...中略

// 1. スレッドで処理するロジック（メソッド）を定義します
static void Run(object count)
{
    int max = (int)count;
    for(int i=0; i<max; i++)
    {
        Thread.Sleep(1000);
        Console.WriteLine("Thr: {0}", i);
    }
}

static void Main(string[] args)
{
    // スレッドで処理するメソッドに渡す引数
    int count = 10;
    // 2. デリゲート（関数ポインタやコマンドパターンに相当）を引数にしてスレッドを作成します
    Thread thr = new Thread(new ParameterizedThreadStart(Run));
    // 3. スレッドを開始します
    thr.Start(count);
    // 4. スレッドが終了するのを待機します
    thr.Join();
}
```

なお、この例は Thread クラスを使用した最も基本的な実装方法です。C# には他にもっと便利なシンタックスが沢山あり、最近はこの様な実装を行なう事は少いかもしれません。
ただ、便利なシンタックスを使ってしまうと、中身をよく理解せずに使えてしまう所があるので、最初は、このプログラムの様にベタな方法で実装する事を理解すると良いと思います。

## クロージャを使用する

クロージャはマルチスレッドの機能ではありませんが、クロージャを利用する事によりマルチスレッドのプログラムが画期的に書き易くなる為、一緒に理解しておきたいシンタックスです。

前述の例だと、スレッドの処理を実行する関数を予め決められたシグナチャ(引数と戻り値が決っている)の関数として定義しておく必要がありますが、
クロージャを利用するとスレッドから呼び出す関数を予め定義する必要がありません。さらに、クロージャの外側にあるローカル変数を自由に参照及び書込みできる点が極めて便利です。
以降の記事を読み進める前に、クロージャについて馴染みの無い方は是非勉強しておいてください。本記事ではクロージャについては詳しく説明していません。

<ol>
<li>スレッドを作成する。この時クロージャ(ラムダ式)をその場で定義して渡す</li>
<li>スレッドを開始する。引数 count はクロージャの性質を利用してローカル変数で渡しているので、ここでは指定しない</li>
<li>別スレッドの終了を待機する場合は Join する</li>
</ol>

``` csharp
using System.Threading;
// ...中略

static void Main(string[] args)
{
    // クロージャに渡す値
    int count = 10;

    // 1. スレッドを作成する。引数にはスレッドで実行する処理の実体をクロージャで定義します
    Thread thr = new Thread(() =>
    {
        // クロージャの外側のローカル変数(count)が、クロージャの中から参照も書込みもできる!
        // ここでは参照だけだが、書き込みがある場合は排他制御が必要なので注意
        int max = count;
        for (int i = 0; i < max; i++)
        {
            Thread.Sleep(1000);
            Console.WriteLine("Thr: {0}", i);
        }
    });
    // 2. スレッドを開始します
    thr.Start();
    // 3. スレッドが終了するのを待機します
    thr.Join();
}
```

## Task クラスを使用した例

次に、.NET Framework 4 で導入されたタスクベースの非同期パターン(TAP)で使用される Task クラスを使用した例を示します。

<ol>
<li>スレッド(タスク)を作成し実行する。この時クロージャ(ラムダ式)をその場で定義して渡す</li>
<li>別スレッドの終了を待機する場合は Wait する</li>
</ol>

``` csharp
using System.Threading;
using System.Threading.Tasks;
// ...中略

static void Main(string[] args)
{
    // クロージャに渡す値
    int count = 10;

    // 1. スレッドを作成して開始する。引数にはスレッドで実行する処理の実体をクロージャで定義します
    Task tsk = Task.Run(() =>
    {
        // クロージャの外側のローカル変数(count)が、クロージャの中から参照も書込みもできる!
        int max = count;
        for (int i = 0; i < max; i++)
        {
            Thread.Sleep(1000);
            Console.WriteLine("Thr: {0}", i);
        }
    });

    // 2. スレッドが終了するのを待機します 
    tsk.Wait();
}
```

これは簡単な例なので先述した Thread クラスが Task に置き換わった程度で、あまり違いはありませんが、C# Task クラスには便利な機能が備わっており、C# でマルチスレッドをプログラミングする場合は、本クラスを多用する事になると思いますので、使い方を押えておいてください。

